package beginner;

import com.sandwich.koan.Koan;

import static com.sandwich.koan.constant.KoanConstants.__;
import static com.sandwich.util.Assert.*;

public class AboutEquality {

	@Koan
	public void doubleEqualsTestsIfTwoObjectsAreTheSame(){
		Object object = new Object();
		Object sameObject = object;
		assertEquals(object == sameObject, __);
		assertEquals(object == new Object(), __);

		/*
			Помните команду - assertSame ? - она сравнивала ссылки а не значения, и как и любой ассерт завершала или продолжала
			выполнение программы.

			Операция == проверку делает ту же, но так как не является "ассертом" - просто возвращает false или true соответственно.

			(На самом деле сама команда assertSame использует == для сравнения и в случае false -  кидает ошибку)

			По сути == всегда сравнивает "содержимое ящиков". Если в ящиках -  значения примитивных типов
			как здесь
				int i1 = 1
				int i2 = 1
		    то результатом сравнения с помощью ==
		    	i1 == i2

		    будет true, так как то что лежит в обоих ящиках - одинаковое - единицы

		    в следующем примере
		    	1 == 1
		    результат идентичен, просто здесь "ящики" - "неявные", "без имени" :)

		    если же мы будем применять эту операцию (кстати, в терминах джавы - "оператор")
		    к переменным ссылочных типов, как здесь:

		    	Integer i1 = new Integer(1);
		    	Integer i2 = new Integer(1);
		    то результатом
		    	i1 == i2
		    будет false
		    так как в ящиках хранятся ссылки на разные обьекты (созданные в разное время с помощью ключевого слова new)
		    а оператор == сравнивает как раз эти ссылки, а не значения (которые ведь одинаковы - и там и там - 1)
		    которые жывует в обьектах которые джава поселила в разные места в памяти

		    А как же тогда сравнить обьекты по значению?
		    - с помощью команды-сообщения equals - она как раз это и делает.
		    поэтому
		    	i1.equals(i2)
		    Вернет true
		 */
	}

	@Koan
	public void equalsMethodByDefaultTestsIfTwoObjectsAreTheSame(){
		Object object = new Object();
		assertEquals(object.equals(object), __);
		assertEquals(object.equals(new Object()), __);

        /*
            Идея этого коана - показать что если мы пошлем команду-сообщение equals - обьекту класа Object
            то результатом будет все равно результат на сравнение ссылок а не значений...

            Это покажет второе сравнение выше (в последней строке кода)

            Почему так?
            Потому что это такое особое свойство, обьектов типа Object, что они понимают эту команду, по-своему,
            не так как все:) Решили выделится:)
         */
	}

	@Koan
	public void equalsMethodCanBeChangedBySubclassesToTestsIfTwoObjectsAreEqual(){
		Object object = new Integer(1);
		assertEquals(object.equals(object), __);
		assertEquals(object.equals(new Integer(1)), __);
		// Note: This means that for the class 'Object' there is no difference between 'equal' and 'same'
        /*
            Шутки шутками:) Но почему же таки обьекты типа Integer и "других" классов понимают одну и ту же команду
            - equals - не так как обьекты типа Object. Особенно учитывая тот факт что эта команда определена именно в
            Object. А значит они, классы которые наследуются от Object (а все классы наследуются от него)
            должны были бы "понимать" эту команду таким же образом.

            Секрет в том, что в класе Object команда equals определена просто "что бы было" :) - с помощью банального
            оператора == - который сравнивает значение ящиков (то есть в случае обьектов - только ссылки, а не настоящие
            значение.

            И это довольно логично. Ведь классу Object сложно предугадать как нужно сравнивать обьекты классов которые
            от него наследуются. В каждом случае нужно будет писать "новый код для сравнения".
            С класом Integer - все просто... Его обьекты запоминают всего лишь одно значение примитивного типа int которое
            передается параметром в момент создания обьекта - new Integer(1)
            Получается нужно сравнивать для разных обьектов вот эти вот "значения" типа инт.
            Но даже этого класс Object предугадать не может:)

            По-этому - каждый класс должен наново определить этот метод equals - говорят - "переопределить".
            Что бы его обьекты "понимали команду equals" правильно, то есть так как и задумано - сравнивать "по значению".

            Если вдруг класс не переопределит equals - то его обьекту будут понимать эту команду так же - как
            сравнение "по ссылке".

            Вопрос - зачем нужна эта "что бы было" реализация метода equals в классе Object? Почему бы просто не определять
            "с нуля" эту команду в классах таких как Integer и другие кому нужно ументь себя сравнивать?

            Ответ - потому что тогда следующий код не будет работать:

                Object object = new Integer(1);
		        assertTrue(object.equals(new Integer(1)));

            только такой:

                Integer object = new Integer(1);
		        assertTrue(object.equals(new Integer(1)));

		    Ну и что? можно спросить...

		    А что мало последнего варианта?

		    Ответ - да, мало:) Хотя с хорошим примером мы познакомимся позже.
		    А пока считайте что, очень часто програмистам нужно делать такие вот вещи:

		        Object object;
		        object = new Integer(1);
		        assertTrue(object.equals(new Integer(1)));
		        object = new Double(3.14);
		        assertFalse(object.equals(new Double(3.15)));
		        object = new String("ku ku");
		        assertFalse(object.equals(new String("uk uk")));

		    То есть иметь один ящик, в который можно пихать обьекты разных типов (именно потому - что они наследуются
		    от одного родителя, переменную которого можно использовать как этот ящик)
		    И потом посылать обьекту хранящимуся в этом ящике ту команду которуя определена в классе ящика (ведь можем
		    посылать только те команды которые принадлежат классу который мы указали при обьявлении ящика) но которая
		    будет интерпретироваться по разному - в зависимости от того - какого класса обьект мы положем в этот ящик.

		    Вот это умение джавы как языка - "определять нужную реализацию метода equals в зависимости от того какого
		    класса обьект живет в ящике" - называется ПОЛИМОРФИЗМОМ и является еще одним принципом ООП.
		    Говорят что ПОЛИМОРФИЗМ в javа реализуется с помощью НАСЛЕДОВАНИЯ. Так как если бы мы не унаследовали наши
		    классы от Object и не переопределили команду - то никакого фокуса бы и не было.

		    Так же и поэтому - более точное название такого полиморфизма - есть Sub-typing polimorphism.
		    (в общем случае полиморфизм есть любое умения языка програмирования выбирать правильную реализацию
		    команд з одинаковым именем  но которые "чем то" отличаются (по сути у нас есть одна команда-сообщение equals которая реализована по разному,
		    в разных местах))) (на самом деле есть еще один вид полиморфизма, который касается конкретно типов
		    а не команд/методов/функций, но об этом говорить пока рано...)

		    Если бы sub-typing полиморфизма не было или мы не обьявили equals в Object, мы бы не смогли обойтись только одним ящиком,
		    - пришлось бы использовать много:

		        Integer object1 = new Integer(1);
		        assertTrue(object.equals(new Integer(1)));
		        Double object2 = new Double(3.14);
		        assertFalse(object.equals(new Double(3.15)));
		        String object3 = new String("ku ku");
		        assertFalse(object.equals(new String("uk uk")));

            У вас уже закипает мозг наверное, а сейчас и крышка взлетит:)
            Но не страшно, попозже вернетесь и перечитаете, когда прийдет момент...

            Так вот... Почему и когда удобно использовать "один ящик" ?

            Ответ: в тех контекстах когда нужно писать универсальный код, который будет работать с разного вида (класа/типа)
            содержанием которые мы будем "подставлять" в этот код в виде параметра (собственно "одного ящика")

            Можно провести аналогию с правилами дорожного движения - это по сути такой "универсальны" код,
            который описывает логику и правила взаимодействия реальных сущностей - людей из реального мира - Коля, Вася, Петя, и т.д.
            , но оперирует обобщенными именами для них - Водитель, Пешеход  - вместо Коля, Вася, Петя....
            Вот эти - Водитель, Пешеход - и есть "параметры".

            И того, предыдущий пример (немного переписаный):
                Object object;
                object = new Integer(1);
		        assertTrue(object.equals(new Integer(1)));
		        object = new Double(3.14);
		        assertTrue(object.equals(new Double(3.15)));
		        object = new String("ku ku");
		        assertTrue(object.equals(new String("uk uk")));

		    можно переписать следующим образом:

                assertEquals(new Integer(1), new Integer(1));           // => PASS
                assertEquals(new Double(3.14), new Double(3.15));       // => FAIL
                assertEquals(new String("ku ku"), new String("uk uk");  // => FAIL

            используя такой вот "универсальный параметризированный код":

                void assertEquals(Integer integerObject1, Integer integerObject2){
                    assertTrue(integerObject1.equals(integerObject2));
                }

                void assertEquals(Double doubleObject1, Double doubleObject2){
                    assertTrue(doubleObject1.equals(doubleObject2));
                }

                void assertEquals(String stringObject1, String stringObject2){
                    assertTrue(stringObject1.equals(stringObject2));
                }

           Как видите ми все еще используем абслютно разные ящики в каждом случае. То есть мы не спользовали сдесь
           sub-typing полиморфизм.

           Но зато... мы сдесь использовали другой тим полиморфизма - "ad hoc" полиморфизм. В джаве он реализауется
           техникой которая называется - overloading - мы переписали метод (команду) с одним и тем же именем - assertEquals - но
           но с параметрами (ящиками) разного типа. Именно потому что "джава поддерживает ad hoc полиморфизм через
           перегрузку методов" она в следующем коде
                assertEquals(new Integer(1), new Integer(1));           // => PASS
                assertEquals(new Double(3.14), new Double(3.15));       // => FAIL
                assertEquals(new String("ku ku"), new String("uk uk");  // => FAIL

           сумеет подобрать правильную реализацию метода assertEuals в соответствии с типом параметров которые методу
           передаются - вот этот подбор отображает поддержку ad hoc полиморфизма джавой, известного чаще под именем "оverloading".

           А вот с помощью наследования (все типы наследуются от Object) мы можем использовать вместо нескольких ящиков
           - один (более точно - "по одному" для каждого параметра), и в резултате вместо трех "перегруженых" методов
           написать всего лишь один:

                void assertEquals(Object object1, Object object2){
                    assertTrue(object1.equals(object2));
                }

          В этот случае... Каждый раз когда будут приходить обьекты разных классов - наследников класса Object
          джава будет подбирать нужную реализацию метода equals - этот "подбор" отображает поддежрку sub-typing
          полиморфизма джавой, известного чаще под именем "просто" полиморфизма в обьектно-ориентированых языках.

          И того, в нашем случае, sub-typing полиморфизм помог достичь более красивого кода меньшим количеством
          усилий (один дополнительный метод вместо трех).
         */
	}

	@Koan
	public void objectsNeverEqualNull(){
		assertEquals(new Object().equals(null), __);
	}

	@Koan
	public void objectsEqualThemselves(){
		Object obj = new Object();
		assertEquals(obj.equals(obj), __);
	}
}
