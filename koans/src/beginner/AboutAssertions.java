package beginner;

// FYI - usually bad practice to import statically, but can make code cleaner
import static com.sandwich.koan.constant.KoanConstants.__;
import static com.sandwich.util.Assert.assertEquals;
import static com.sandwich.util.Assert.assertFalse;
import static com.sandwich.util.Assert.assertNotNull;
import static com.sandwich.util.Assert.assertNotSame;
import static com.sandwich.util.Assert.assertNull;
import static com.sandwich.util.Assert.assertSame;
import static com.sandwich.util.Assert.assertTrue;

import com.sandwich.koan.Koan;

public class AboutAssertions {

	@Koan 
	public void assertBooleanTrue() {
		assertTrue(__); // should be true really
		/*
			команды которые начинаются со слова assert особенны тем, что проверяют параметры которые им передаются
			на сооответствие определенным условиям, которые обычно описаны в имени самой "assert" команды.
			Если проверка прошла успешно - ассерт больше ничего не делает, и код продолжает выполнятся дальше.
			Говорят "ассерт прошел".
			Если проверка прошла не успешно, и параметры не соответсвуют тому что от них ожидает ассерт, то ассерт
			бросит ошибку (exception) и остановит исполнение программы (в нашем случае - коана)
			Говорят "ассерт не прошел", "ассерт упал", "коан упал"...

			В нашем случае assertTrue ожидает что параметр который будет ему передан - будет - true
			(true - это значение типа Boolean)

			__ - то что в скобках - это такая переменная значение которой "REPLACE ME" - его вы будете видеть
			в консольке.
			В даном случае вы должны увидеть: expected:<true> but was:<REPLACE ME>
			Это и есть одна из вашых подсказок, намекающая что вместо __ нужно подставить  true

			Всегда учитываете то что подсказывается вам в консольке, но и не копируйте бездумно заменяя __ на то что
			встречается в expected: <здесь>. Старайтесь понять - почему, зачем. Гуглите или ищите ответы в книгах.
		 */
	}

	@Koan
	public void assertBooleanFalse() {
		assertFalse(__);
		/*
			false - есть одно из значений типа boolean
			Всево их два: true и false

            todo: provide more examples of usage
		 */
	}
	
	@Koan
	public void assertNullObject(){
		assertNull(__);

        /*
            null - специальное значение, которое означает "отсутсвие чего либо" :)
         */
	}
	
	@Koan
	public void assertNotNullObject(){
		assertNotNull(null); // anything other than null should pass here...
	}

	@Koan
	public void assertEqualsUsingExpression(){
		assertTrue("Hello World!".equals(__));
        /*
            до этого в коанах мы встречали только "независимые самостоятельные команды", которые получали
            на вход параметры и сами выполняли какую ту работу.
            Например - fail("Программа была прервана. Случилась ошибка") - команда которая кидает ошибку с соответствующим
            сообщением, передаваемым в виде параметра.

            В джаве такие команды называются - статическими, и в момент создания нужно указывать это явно, добавляя
            слово static перед типом возвращаемого значения (или void). Например: public static void fail()

            Так вот:) Есть другой тим команд (методов - если использовать терминологию джавы) - "команды-сообщения".

            Они не самостоятельны:) Их нельзя вызвать просто так, написав имя такой команды.
            Такие команды нужно посылать обьектам через точку между обьектом и именем команды.
            Например:
                "Hello World!".equals("Hello World");

            В даном случае мы посылаем обьекту "Hello World!" команду-сообщение equals передавая параметр "Hello World"
            Мы как бы действытельно посылая сообщение - камандуем бьекту стоящему слева от точки -
            "Ей, слыш, а ну сравни ка сам себя с другим обьектом (который мы указываем как параметр) - "Hello World"
            и верни результат - равен ли ты параметру или нет - true или false ?

            В нашем примере equals вернет false, так как у обьекта-параметра нет знака восклицания в конце.

            Об обьектах... Они отличаются от "просто значений" как раз тем, что они "умные", что они понимают определенный
            набор команд-сообщений и соответсвенно которые можно им "послать" через точку.
            (На самом деле отличие не только в этом, но об этом - позже)

            По сути так же как типы "тупых" значений определяют опереации над своими значениями
            (пример: значения целого типа (int) можно сумировать: 1 + 2)
            Так и типы обьектов - определяют набор команд-сообщений которые можно посылать обьектам этих типов (еще говорят -
            экземплярам этих типов)

            Вот эти типы "тупых" значений - называются "примитивными" типами в дажве
            А типы "умных" обьектов - называются классами, или "ссылочными типами" (referenced types) (еще можно называть
            их "пользовательскими типами" или "кастомными типами" так как они создаются самими програмистами)
            Почему же "официально" они известны как "ссылочные типы" мы узнаем позже...

            Пока не забывайте о том, что обьекту можно посылать только те команды-сообщения которые определены в его типе.

            И да, тип обьектов вот этих "штук в кавычках" - то ест строк текста - String ;)
         */
	}

	@Koan
	public void assertEqualsWithBetterFailureMessage(){
		assertEquals(1, __);
        /*
            эта команда сравнивает параметры которые ей передаются. И как и любой ассерт - кидает ошыбку в случае
            в даном случае "неравенства" (а не возвращает false как например команда-сообщение equals)
         */
	}

    /*
        всегда обращайте внимание на имена коанов - часто, они обьясняет что же в нем происходит, и коротко
        описывают то что вы должны выучить/запомнить.
     */
	@Koan
	public void assertEqualsWithDescriptiveMessage() {
		// Generally, when using an assertXXX methods, expectation is on the 
		// left and it is best practice to use a String for the first arg 
		// indication what has failed
		assertEquals("The answer to 'life the universe and everything' should be 42", 42, __);

        /*
            хотя эта команда имеет то же имя что и команда из предыдущего коана, - это совсем другая команда

            Отличие для джавы - как раз в том что предыдущая команда примала два параметра  - а эта три.

            По смыслу - различие в том что эта команда в случае "неравенства" второго и третьего параметров
            -  не просто кинет ошибку, но еще и "прикрепит" к ней сообщение которое мы передаем первым параметром.
         */
	}
	
	@Koan
	public void assertSameInstance(){
		Object same				= new Integer(1);
		Object sameReference	= __;
		assertSame(same, sameReference);

        /*
            ***

            В этом коане мы видим пример использования переменных класов (то есть "умных" типов)
            (до этого мы встречали переменные "примитивных" типов) (ну и неявно переменную __ которая на самом деле
            тоже есть переменной класа String, то есть "умного типа")

            Существование двух видов типов в джава, накладывает свои особенности на использование их переменных.
            С точки зрения програмиста использование переменных выглядит одинаково. Но то что "происходит под капотом" -
            отличается.

            Можно попробовать понять что же там происходит на примере с теми же ящиками:)

            Если представить что переменная это ящик, то можно считать что ящик для переменной можно построить
            в контексте величины только до определенного размера.
            С значениями примитивных типов - все довольно просто - все они "помещаются" в такие ящики (значениям одних
            примитивных типов нужно меньше места (к примеру int), значениям других (например long) - больше - но всем хватает)

            А вот с обьектами, которые - экземпляры классов ("умных" типов) - ситуация другая. Они настолько "умные",
            что вместе со всеми своими "мозгами" в ящик не помещаются. Джаве приходится их "селить" в отдельные "отели"
            где то в памяти:) и все что она может поместить в такой ящик переменной какого то класса  - это адрес этого
            отеля, или "в терминах джава" - ссылку на обьект (который живет где то в памяти).
            Именно по-этому классы еще называют "ссылочными типами", потому что их переменные хранят только ссылки, а не
            реальные обьекты.

            Как помните, при обьявлении переменной нужно указывать явно какого типа будет лежать обьект в этом ящике.
            Это нужно как раз для того что бы было ясно "как общаться" с тем что лежит внутри ящика - какие операции можно
            с ним совершать (в случае значений примитивных типов) или какие команды-сообщения можно посылать (в случае обьектов
            классов). Другими словами тип переменной определяет "интерфейс" общения с тем что хранится внутри.
            Но иногда, можно этот "интерфейс" урезать.

            Для того что бы понять как происходит это "урезание" :) Рассмотрим пример с классом Integer.
            (класс Integer - это такая "умная" альтернатива примитивному типу int)

            На самом деле не все команды-сообщения которые могут принимать обьекты класса Integer определены именно
            в этом классе. Несколько других команд (как equals например) определены в классе от которого "наследуется"
            Integer. И класс этот - Object. Говорят - Object - класc-родитель (parent class) для класса Integer, который
            соответственно является классом-ребенком (child class) класса Object.

            Наследования чайлд классом свойств и команд своего "перента" называется НАССЛЕДОВАНИЕМ и есть одним
            из принцыпов ООП (= обьектно ориентированого программирования).

            Так вот, есть способ указать джаве: несмотря на то что обьект который мы ложим в ящик -  есть обьектом класса Integer,
            позволяется использовать только те команды которые определены в его родителе - Object.
            Именно это и делается в нашем коане:
                Object same	= new Integer(1);

            Это например значит следующее:
                Несмотря на то що класс Integer описывает команду-сообщение: doubleValue
                    (это команда которая возвращает значение живущее в обьекте класса Integer - в виде вещественного числа,
                    по сути - делая "конвертацию из int в double)
                и значет допустимо писать код:
                    println((new Integer(1)).doubleVlaue()); // команда println - выводит значение параметра своего на экран
                или
                    Integer integerObject = new Integer(1);
                    println(integerObject.doubleValue());
                при том мы не можем написать:
                    println(same.doubleValue())
                потому что мы "урезали интерфейс общения с обьектом класса Integer только до команд описаных в классе
                Object".

                но можем использовать "не урезанный" equals:
                    println(same.equals(same));

                (пока мы не обьясняли что делает команда-сообщение equals - оставим это на позже.... пока же можете
                положиться на свою интуицию);

            Кстати  Object - есть общим родителем для всех класов. Это значит что обьекты любых класов также понимают
            вот этот стандарнтый "набор команд" определенный в Object - как минимум мы знаем уже одну такую команду-сообщение
            - equals. И так же - обьект любого класа можно положыть в "ящик для класса Object" :) (не забываем -
            что на самом деле "не сам обьект ложится в ящик, а ссылка на него", но для удобства мы будем этот нюанс в общении
            упускать)


            *** new Integer(1) ***

            Что это за слово new такое?
            - Это ключевое слово джава которое используется как раз для того что бы создавать обьекты соответствующих
            классов по определенным "параметрам".
            И того,  в нашем примере:

                Object same	= new Integer(1);
                              |
                              Создается обьект класса Integer по параметру - значению 1 примитивного типа int
                            |
                            и ссылка на этот обьект  ложится в
                |
                переменную с именем same - (ящик) класса Object - то есть ящик, общаться с сущностью внутри которого
                - можно только с помощью команд определенных в Object


            *** assertSame(same, sameRefence) ***

            assertSame - специальная ассерт-команда, целью проверки которой есть:
            - проверить ссылки ли не на один и то же обьект жывут в параметрах которые ей (команде) передаются.
            то есть в нашем случае использования - Указывают ли сылки живущие в ящиках - same и sameReference - на один
            и тот же обьект в памяти.
         */
	}
	
	@Koan
	public void assertNotSameInstance(){
		Integer same           = new Integer(1);
		Integer sameReference  = same;
		assertNotSame(same, sameReference);
	}
}
